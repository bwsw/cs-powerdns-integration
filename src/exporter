#!/usr/bin/python
# -*- coding: UTF-8 -*-

import sys
sys.path.append(".")

import logging
import datetime
import re
import json
import os
import traceback
from datetime import datetime
from kafka import KafkaConsumer
from kafka.errors import KafkaError
import mysql.connector
from cs import CloudStack
from lib.virtual_machine import VirtualMachine

FORMAT = '%(asctime)-15s %(message)s'
logging.basicConfig(format=FORMAT, stream=sys.stderr, level=logging.INFO)

kafka_bootstrap_hosts = os.environ["KAFKA_BOOTSTRAP"]
kafka_topic = os.environ["KAFKA_TOPIC"]
kafka_group = os.environ["KAFKA_GROUP"]

mysql_pdns_name = os.environ['MYSQL_PDNS_NAME']
mysql_pdns_user = os.environ['MYSQL_PDNS_USER']
mysql_pdns_password = os.environ['MYSQL_PDNS_PASSWORD']
mysql_pdns_host = os.environ['MYSQL_PDNS_HOST']
mysql_pdns_port = int(os.environ['MYSQL_PDNS_PORT'])

cs_endpoint = os.environ['CS_ENDPOINT']
cs_api_key = os.environ['CS_API_KEY']
cs_secret_key = os.environ['CS_SECRET_KEY']

dns_record_ttl = os.environ['DNS_RECORD_TTL']
dns_common_zone = os.environ['DNS_COMMON_ZONE']
dns_add_to_common_zone = os.environ['DNS_ADD_TO_COMMON_ZONE']

pdns_conn = mysql.connector.connect(host = mysql_pdns_host, port = mysql_pdns_port,
                            user = mysql_pdns_user, passwd = mysql_pdns_password, database = mysql_pdns_name)

pdns_cursor = pdns_conn.cursor()
pdns_cursor.execute("CREATE TABLE IF NOT EXISTS cs_mapping(uuid CHAR(36), record VARCHAR(255), UNIQUE(uuid, record))");
pdns_conn.commit()

pdns_cursor.close()

consumer = KafkaConsumer(kafka_topic,
                         group_id = kafka_group,
                         bootstrap_servers = kafka_bootstrap_hosts.split(","),
                         value_deserializer = lambda m: json.loads(m.decode('utf8')),
                         enable_auto_commit = False)

cs = CloudStack(endpoint = cs_endpoint,
                key = cs_api_key,
                secret = cs_secret_key)

def extract_create_payload(job_result):
    job_result = job_result.replace("org.apache.cloudstack.api.response.UserVmResponse/virtualmachine/", "", 1)
    return json.loads(job_result)

def update_a_zone(cursor, vm, domain):
    cursor.execute("SELECT id FROM domains WHERE name = %s", (domain, ))
    fqdn = vm.name + "." + domain
    row = cursor.fetchone()
    if row is not None:
        domain_id = row[0]
        cursor.execute("""REPLACE INTO records (name, type, content, ttl, prio, change_date, ordername, auth, domain_id) VALUES (%s, 'A', %s, %s, 0, UNIX_TIMESTAMP(), %s, 1, %s)""", (fqdn, vm.ip4, dns_record_ttl, vm.name, domain_id))
        if vm.ip6 is not None:
            cursor.execute("""REPLACE INTO records (name, type, content, ttl, prio, change_date, ordername, auth, domain_id) VALUES (%s, 'AAAA', %s, %s, 0, UNIX_TIMESTAMP(), %s, 1, %s)""", (fqdn, vm.ip6, dns_record_ttl, vm.name, domain_id))
        cursor.execute("""INSERT IGNORE INTO cs_mapping (uuid, record) VALUES(%s,%s)""", (vm.uuid, fqdn))


def update_ptr_zone(cursor, vm):
    cursor.execute("SELECT id FROM domains WHERE name = %s", (vm.ip4_ptr_zone, ))
    row = cursor.fetchone()
    if row is not None:
        domain_id = row[0]
        cursor.execute("""REPLACE INTO records (name, type, content, ttl, prio, change_date, auth, domain_id) VALUES (%s, 'PTR', %s, %s, 0, UNIX_TIMESTAMP(), 1, %s)""", (vm.ip4_ptr, vm.fqdn, dns_record_ttl, domain_id))
        cursor.execute("""INSERT IGNORE INTO cs_mapping (uuid, record) VALUES(%s,%s)""", (vm.uuid, vm.ip4_ptr))

    if vm.ip6 is not None:
        cursor.execute("SELECT id FROM domains WHERE name = %s", (vm.ip6_ptr_zone, ))
        row = cursor.fetchone()
        if row is not None:
            domain_id = row[0]
            cursor.execute("""REPLACE INTO records (name, type, content, ttl, prio, change_date, auth, domain_id) VALUES (%s, 'PTR', %s, %s, 0, UNIX_TIMESTAMP(), 1, %s)""", (vm.ip6_ptr, vm.fqdn, dns_record_ttl, domain_id))
            cursor.execute("""INSERT IGNORE INTO cs_mapping (uuid, record) VALUES(%s,%s)""", (vm.uuid, vm.ip6_ptr))


def create_new_records(m):
    mct = "commandEventType"
    mcv = "VM.CREATE"
    ms = "status"
    msv = "SUCCEEDED"
    jr = "jobResult"

    if mct in m and ms in m and m[mct].lower() == mcv.lower() and m[ms].lower() == msv.lower():
        job_result = extract_create_payload(m[jr])

        vm = VirtualMachine(
                cs_api = cs,
                vm_info = job_result)

        if not (vm.domain and vm.ip4):
            return

        vm.dump()

        c = pdns_conn.cursor()

        # delete old a records
        c.execute("DELETE FROM records WHERE name = %s", (vm.fqdn,))

        # Add A, AAAA records
        update_a_zone(c, vm, vm.domain)
        if dns_add_to_common_zone == 'true':
            update_a_zone(c, vm, dns_common_zone)

        # Add PTR records
        update_ptr_zone(c, vm)
        pdns_conn.commit()
        c.close()


def delete_removed_records(m):
    vm_field     = "VirtualMachine"
    status_field = "status"
    status_value = "Completed"
    event_field  = "event"
    event_value  = "VM.DESTROY"
    if vm_field in m and status_field in m and event_field in m and m[status_field].lower() == status_value.lower() and m[event_field].lower() == event_value.lower():
        vm_uuid = m[vm_field].lower()
        c = pdns_conn.cursor()
        c.execute("SELECT record FROM cs_mapping where uuid = %s", (vm_uuid,))
        rows = c.fetchall()
        for r in rows:
            logging.info("Deleting DNS entries: %s" % r[0])
            c.execute("DELETE FROM records WHERE name = %s", r)
        c.execute("DELETE FROM cs_mapping WHERE uuid = %s", (vm_uuid,))
        pdns_conn.commit()
        c.close()

for m in consumer:
    pdns_conn.ping()
    m = m.value
    create_new_records(m)
    delete_removed_records(m)
    consumer.commit()
